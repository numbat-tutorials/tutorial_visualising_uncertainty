---
title: "WOMBAT 2025 Tutorial"
subtitle: "Visualising Uncertainty"
author: 
  - name: "Harriet Mason, Dianne Cook"
institute: "Department of Econometrics and Business Statistics"
format: 
  revealjs:
    theme: 
      - default 
      - custom.scss
    width: 1600
    height: 900
    margin: 0.1
    slide-number: c/t
    embed-resources: true
code-line-numbers: false
code-fold: true
message: false
highlight-style: pygments
title-slide-attributes:
  data-background-color: "#006dae"
  data-background-opacity: "0.5"
footer: "[https://numbat-tutorials.github.io/tutorial_visualising_uncertainty/](https://numbat-tutorials.github.io/tutorial_visualising_uncertainty/)"
---

```{r, include = FALSE}
#| label: libraries-for-participants
library(ggplot2)
library(tidyr)
library(dplyr)
library(readr)
library(readxl)
library(stringr)
library(forcats)
library(colorspace)
library(patchwork)
library(broom)
library(ggbeeswarm)
library(ggforce)
library(ggdist)
library(ggridges)
library(ggmosaic)
library(nullabor)
library(ozmaps)
library(sf)
library(rmapshaper)
library(ggthemes)
library(conflicted)
conflicts_prefer(dplyr::filter)
conflicts_prefer(dplyr::select)
conflicts_prefer(dplyr::slice)
conflicts_prefer(dplyr::rename)
conflicts_prefer(dplyr::mutate)
conflicts_prefer(dplyr::summarise)
```

```{r, include = FALSE}
#| label: options-for-nice-slides
options(width = 200)
knitr::opts_chunk$set(
  fig.width = 5,
  fig.height = 5,
  fig.align = "center",
  dev.args = list(bg = 'transparent'),
  out.width = "100%",
  fig.retina = 5,
  dpi = 150, 
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  cache = FALSE
)
```

```{r, include = FALSE}
#| label: theme-for-nice-plots
theme_set(ggthemes::theme_gdocs() + #base_size = 14) +
  theme(plot.background = 
        element_rect(fill = 'transparent', colour = NA),
        #axis.line.x = element_line(color = "black", 
        #                           linewidth = 0.4),
        #axis.line.y = element_line(color = "black", 
        #                           linewidth = 0.4),
        panel.grid.major = element_line(color = "grey90"),
        axis.ticks = element_line(color = "black"),
        #plot.title.position = "plot",
        #plot.title = element_text(size = 14),
        panel.background  = 
          element_rect(fill = 'transparent', colour = "black"),
        legend.background = 
          element_rect(fill = 'transparent', colour = NA),
        legend.key        = 
          element_rect(fill = 'transparent', colour = NA)
  ) 
)
```


## Welcome üëãüèº 

:::: {.columns}
::: {.column width="45%"}

Thanks for joining to learn about making data plots today. 

::: {style="font-size: 80%;"}

ü¶ò **[Di](https://www.dicook.org)** is a *Professor of Statistics*. She has more than 30 years of research and teaching of data visualisation, and open source software development.  <br>
üê® **[Harriet](https://harrietmason.netlify.app/)** is a *final year PhD student*, working on better representation of uncertainty in data visualisations, particularly focused on spatial data. <br>

*We are both in Econometrics and Business Statistics, at Monash University.* 
:::

:::
::: {.column width="5%"}

:::
::: {.column width="45%"}
::: {.fragment}

üß© Feel free to ask questions any time. ü§î

::: {style="font-size: 80%;"}
<br>

üéØ The objectives for today are:

1. 
2. 
3. 

Caution: Incorporating uncertainty into plots is far from  state of best practices. This is our best attempt to summarise current literature, what we find to be valuable approaches and available tools.

:::

:::
:::
::::


# Session 1 <br> Foundations of uncertainty in data visualisations {.transition-slide .center-align}

# Introduction {.transition-slide style="align: center;"}

## What is uncertainty?

:::: {.columns}
::: {.column width=20%}

<br><br>
*You don't know what you don't know*

:::
::: {.column width=50%}
::: {.incremental}
- Statistical (aleatory) uncertainty
    - notion of randomness
    - variability in the outcome/measurements
- Systemic (epistemic) uncertainty
    - due to bias, misunderstanding, assumptions
    - measurement error
    - handling of missing information, and pre-processing choices
    - model choices
    - incorrect comparisons
    - *can you think of any others?*

:::

:::
::: {.column width=30%}

::: {.fragment}

::: {.callout-note appearance="simple"}

::: {style="font-size: 150%;"}

Mostly we are concerned about representing statistical uncertainty.

:::

:::

:::

:::
::::

# Common measures and representations {.transition-slide  .center-align}

## Show the data [(1/4)]{.f50}

:::: {.columns}

::: {.column}

::: {.callout-note appearance="simple"}

::: {style="font-size: 150%;"}

The most valuable way to show uncertainty is to show all the data.

:::

:::

Plot shows first preference % for greens in the 2019 Australian Federal Election, for the 150 electorates. 

Plot of choice is the **jittered dotplot**, where points are spread vertically according to density.


:::
::: {.column}

::: {style="font-size: 70%;"}
```{r}
#| label: election1
election <- read_csv(here::here("session1/data/election2019.csv"),
  skip = 1,
  col_types = cols(
    .default = col_character(),
    OrdinaryVotes = col_double(),
    AbsentVotes = col_double(),
    ProvisionalVotes = col_double(),
    PrePollVotes = col_double(),
    PostalVotes = col_double(),
    TotalVotes = col_double(),
    Swing = col_double()
  )
)
e_grn <- election |>
  group_by(DivisionID) |>
  summarise(
    DivisionNm = unique(DivisionNm),
    State = unique(StateAb),
    votes_GRN = TotalVotes[which(PartyAb == "GRN")],
    votes_total = sum(TotalVotes)
  ) |>
  mutate(perc_GRN = votes_GRN / votes_total * 100)

e_grn |>
  mutate(State = fct_reorder(State, perc_GRN)) |>
  ggplot(aes(x=perc_GRN, y=State)) +
    geom_quasirandom(groupOnX = FALSE, varwidth = TRUE) +
    labs(
      x = "First preference votes %",
      y = ""
    ) +
  xlim(c(0,50))

```
:::

:::
::::

## Show the data [(2/4)]{.f50}

:::: {.columns}

::: {.column}

```{r}
#| label: election1
#| echo: false
```

:::
::: {.column}

What do we learn?

::: {.incremental}
- Different number of observations in each state
- One outlier in Vic
- As a group, ACT has higher %'s
- Vic has a small cluster of points with higher %'s
- %'s are mostly very low
:::

::: {.fragment}
This plot ONLY shows uncertainty! 
:::

:::
::::

## Show the data [(3/4)]{.f50}

:::: {.columns}

::: {.column}

What would be other common ways to display this data?

::: {.incremental}
- Side-by-side boxplots
- Side-by-side violin
- On a map of electorates
:::

::: {.fragment}
For each plot think about 

- what is uncertainty, and what is estimate
- what the plot shows or hides

:::

:::
::: {.column}


::: {.panel-tabset}

## Dotplot

```{r}
#| label: election1
#| echo: false
#| out-width: 80%
```

## Boxplot

::: {style="font-size: 70%;"}
```{r}
#| label: election2
#| out-width: 80%
e_grn |>
  mutate(State = fct_reorder(State, perc_GRN)) |>
  ggplot(aes(x=perc_GRN, y=State)) +
    geom_boxplot(varwidth = TRUE) +
    labs(
      x = "First preference votes %",
      y = ""
    ) +
  xlim(c(0,50))
```
:::

## Violin

::: {style="font-size: 70%;"}
```{r}
#| label: election3
#| out-width: 80%
e_grn |>
  mutate(State = fct_reorder(State, perc_GRN)) |>
  ggplot(aes(x=perc_GRN, y=State)) +
    geom_violin(draw_quantiles = c(0.25, 0.5, 0.75),
      fill="#006dae", alpha=0.5) +
    labs(
      x = "First preference votes %",
      y = ""
    ) +
  xlim(c(0,50))
```
:::

## Map

::: {style="font-size: 70%;"}
```{r}
#| label: election4
#| fig-width: 8
#| fig-height: 6
#| out-width: 100%
oz_states <- ozmaps::ozmap_states %>% filter(NAME != "Other Territories")
oz_votes <- rmapshaper::ms_simplify(ozmaps::abs_ced)
oz_votes_grn <- full_join(oz_votes, e_grn, by=c("NAME"="DivisionNm"))

ggplot(oz_votes_grn, aes(fill=perc_GRN)) +
  geom_sf(colour="white") +
  scale_fill_viridis_c(direction=-1, trans = "log", 
    guide = "colourbar", 
    labels = scales::label_number(accuracy = 0.1)) +
  theme_map() +
  theme(legend.position = "right", 
    legend.title = element_blank())
```
:::


:::

:::
::::

## Show the data [(4/4)]{.f50}

:::: {.columns}

::: {.column}

::: {.callout-note appearance="simple"}

::: {style="font-size: 150%;"}

Even when you think you are showing the data, it is often an estimate and some representation of uncertainty.

:::

:::

<br><br>

The election data is actually estimates. The electorates are strata, so what was shown was % computed on each strata. 

What is the full data? What are different strata possible?

::: {.fragment}

::: {style="font-size: 70%;"}
Generally, we trust the values provided by AEC, and we explore the distribution of votes by different strata in the electorate structure. The goal being to understand the variability in the way the people have voted, identify electorates where the winner might flip next time, ... 
:::

:::

:::
::: {.column width=25%}

::: {.fragment}

<br><br>
<br><br>
<br><br>
<br><br>
<br><br><br>


*It's really difficult to concretely define uncertainty!*


:::

:::
::::

## Terminology

:::: {.columns}

::: {.column}

Names for main thing:

- estimate
- statistic
- signal 

Names for uncertainty, needed to understand main thing:

- variation 
- variability
- variance/standard deviation
- error/standard error
- IQR/MAD
- noise 

:::
::: {.column width=40%}

::: {.callout-note appearance="simple"}

::: {style="font-size: 150%;"}

Displaying uncertainty is described **signal suppression**.
:::

:::
:::
::::

## Example: distributions

```{r}
#| eval: false
#| echo: false
melbtemp <- read_csv(here::here("session1/data/melb_temp.csv")) |>
  janitor::clean_names() |>
  dplyr::rename(temp = `maximum_temperature_degree_c`) |>
  mutate(month = fct_recode(month, 
                            "Jan"="01",
                            "Feb"="02",
                            "Mar"="03",
                            "Apr"="04",
                            "May"="05",
                            "Jun"="06",
                            "Jul"="07",
                            "Aug"="08",
                            "Sep"="09",
                            "Oct"="10",
                            "Nov"="11",
                            "Dec"="12")) |>
  mutate(day = as.numeric(day)) |>
  filter(year > 1972, year < 2020) |>
  dplyr::select(year, month, day, temp)
save(melbtemp, file="session1/data/melbtemp.rda")
```

::: {.panel-tabset}

## Variations in plot choices

::: {style="font-size: 70%;"}

```{r}
#| label: distributions
#| fig-width: 18
#| fig-height: 8
#| out-width: 80%
load("data/melbtemp.rda")
melbtemp_2019 <- melbtemp |>
  filter(year == 2019)
  
d1 <- ggplot(melbtemp_2019, aes(x=month, y=temp)) +
  geom_quasirandom() + 
  stat_summary(geom="point", fun="median", 
    colour="red", size=3) +
  xlab("") + ylab("Temp (C)") +
  ggtitle("A. ggbeeswarm::geom_quasirandom")
  
library(ggforce)
d2 <- ggplot(melbtemp_2019, aes(x=month, y=temp)) +
  geom_violin(fill = "#6F7C4D", colour=NA, alpha=0.7) +
  geom_sina() +
  xlab("") + ylab("Temp (C)") +
  ggtitle("B. geom_violin + ggforce::geom_sina")

library(ggridges)
d3 <- ggplot(melbtemp_2019, aes(x=temp, y=month)) +
  geom_density_ridges(scale = 1.5, 
                      quantile_lines = TRUE,
                      quantiles = 2,
                      fill = "#6F7C4D") +
  xlab("Temp (C)") + ylab("") + 
  theme_ridges() +
  ggtitle("C. ggridges::geom_density_ridges")

library(ggdist)
d4 <- ggplot(melbtemp_2019, aes(x=temp, y=month)) +
  stat_halfeye(fill="#6F7C4D", alpha=0.7) +
  geom_point(pch = "|", size = 2,
    position = position_nudge(y = -.15)) +
  xlab("Temp (C)") + ylab("") +
  ggtitle("D. ggdist::stat_halfeye")

lout <- c(area(1,2),
          area(3),
          area(4))
lout <- "
AACD
BBCD
"
d1 + d2 + d3 + d4 + plot_layout(design=lout)
```

:::

## Consider these things

- What is the main element?
- How is the uncertainty displayed?
- What is the uncertainty pattern? And then, what would be an appropriate representation?
- What are the key features of the data that we need to preserve in a plot?
- Why the different aspect ratios?

<!-- Distributions: density-jittered dotplot (ggbeeswarm, ggforce::geom_sina, geom_violin, ggridges)
-->

:::

## Exercise 1

Continue working with the Melbourne temperature data:

1. Decide on the appropriate information about the uncertainty that needs to be included in the display.
2. Play with different options on your choice of display to make various displays. Aim to have three different designs.
3. Is there a winner, or several roughly equally good displays?

```{r}
#| echo: false
countdown::countdown(10, left="50%", bottom="40%",
  color_background="#027EB6",
  color_text="white",
  color_running_background="#027EB6",
  color_running_text="white",
  color_finished_background="#D93F00")
```

# How this affects perception {.transition-slide}

## Why it it "signal suppression"? 

::: {.panel-tabset}

## model

:::: {.columns}
::: {.column width=20%}

Plotting the fitted model alone

:::
::: {.column}

::: {style="font-size: 70%;"}

```{r}
#| label: model
#| fig-width: 6
#| fig-height: 4
#| out-width: 100%
library(brolgar)
library(lme4)
library(modelr)
data("wages")
wages_fct <- wages |>
  select(id, ln_wages, xp, high_grade) |>
  mutate(high_grade = factor(high_grade))
wages_fit <- lmer(ln_wages~xp + high_grade + (xp|id), data=wages_fct)
wages_fe <- summary(wages_fit)$coefficients
wages_fe_d <- tibble(xp = rep(seq(0, 13, 1), 7),
     high_grade = rep(c(6, 7, 8, 9, 10, 11, 12), rep(14, 7))) |>
  mutate(ln_wages = case_when(
    high_grade == 6 ~ wages_fe[1,1] + wages_fe[2,1]*xp,
    high_grade == 7 ~ wages_fe[1,1] + wages_fe[3,1] + wages_fe[2,1]*xp,
    high_grade == 8 ~ wages_fe[1,1] + wages_fe[4,1]  + wages_fe[2,1]*xp,
    high_grade == 9 ~ wages_fe[1,1] + wages_fe[5,1]  + wages_fe[2,1]*xp,
    high_grade == 10 ~ wages_fe[1,1] + wages_fe[6,1]  + wages_fe[2,1]*xp,
    high_grade == 11 ~ wages_fe[1,1] + wages_fe[7,1]  + wages_fe[2,1]*xp,
    high_grade == 12 ~ wages_fe[1,1] + wages_fe[8,1]  + wages_fe[2,1]*xp)
  ) |>
  mutate(high_grade = factor(high_grade))
ggplot(wages_fe_d) + 
  geom_line(aes(x=xp, 
                y=ln_wages, 
                colour=high_grade, 
                group=high_grade)) +
  scale_colour_discrete_divergingx(palette = "Zissou 1") +
  labs(x="Experience (years)", y="Wages (ln)", colour="Grade") 
```
:::

:::
::::

## and data

:::: {.columns}
::: {.column width=40%}

Adding the data makes the model look less impressive

:::
::: {.column}

::: {style="font-size: 70%;"}

```{r}
#| label: modelanddata
#| fig-width: 6
#| fig-height: 4
#| out-width: 100%
ggplot() + 
  geom_line(data=wages_fct, aes(x=xp, y=ln_wages, group=id), alpha=0.1) +
  geom_line(data=wages_fe_d, aes(x=xp, 
                y=ln_wages, 
                colour=high_grade, 
                group=high_grade)) +
  scale_colour_discrete_divergingx(palette = "Zissou 1") +
  labs(x="Experience (years)", y="Wages (ln)", colour="Grade") 
```

:::
:::
::::

## and SE

:::: {.columns}
::: {.column width=40%}

Standard errors as produced by the model fit. 
:::


::: {.column }

::: {style="font-size: 70%;"}

```{r}
#| label: SE
#| fig-width: 6
#| fig-height: 4
#| out-width: 100%
wages_fe_d <- wages_fe_d |>
  mutate(ln_wages_l = case_when(
    high_grade == 6 ~ wages_fe[1,1] - wages_fe[1,2] +
                      (wages_fe[2,1]-wages_fe[2,2])*xp ,
    high_grade == 7 ~ wages_fe[1,1] - wages_fe[1,2] + 
                      wages_fe[3,1] - wages_fe[3,2] + 
                      (wages_fe[2,1]-wages_fe[2,2])*xp,
    high_grade == 8 ~ wages_fe[1,1] - wages_fe[1,2] + 
                      wages_fe[4,1] - wages_fe[4,2] + 
                      (wages_fe[2,1]-wages_fe[2,2])*xp,
    high_grade == 9 ~ wages_fe[1,1] - wages_fe[1,2] + 
                      wages_fe[5,1] - wages_fe[5,2] + 
                      (wages_fe[2,1]-wages_fe[2,2])*xp,
    high_grade == 10 ~ wages_fe[1,1] - wages_fe[1,2] + 
                      wages_fe[6,1] - wages_fe[6,2] + 
                      (wages_fe[2,1]-wages_fe[2,2])*xp,
    high_grade == 11 ~ wages_fe[1,1] - wages_fe[1,2] + 
                      wages_fe[7,1] - wages_fe[7,2] + 
                      (wages_fe[2,1]-wages_fe[2,2])*xp,
    high_grade == 12 ~ wages_fe[1,1] - wages_fe[1,2] + 
                      wages_fe[8,1] - wages_fe[8,2] + 
                      (wages_fe[2,1]-wages_fe[2,2])*xp)
  ) |>
  mutate(ln_wages_u = case_when(
    high_grade == 6 ~ wages_fe[1,1] + wages_fe[1,2] +
                      (wages_fe[2,1]+wages_fe[2,2])*xp ,
    high_grade == 7 ~ wages_fe[1,1] + wages_fe[1,2] + 
                      wages_fe[3,1] + wages_fe[3,2] + 
                      (wages_fe[2,1]+wages_fe[2,2])*xp,
    high_grade == 8 ~ wages_fe[1,1] + wages_fe[1,2] + 
                      wages_fe[4,1] + wages_fe[4,2] + 
                      (wages_fe[2,1]+wages_fe[2,2])*xp,
    high_grade == 9 ~ wages_fe[1,1] + wages_fe[1,2] + 
                      wages_fe[5,1] + wages_fe[5,2] + 
                      (wages_fe[2,1]+wages_fe[2,2])*xp,
    high_grade == 10 ~ wages_fe[1,1] + wages_fe[1,2] + 
                      wages_fe[6,1] + wages_fe[6,2] + 
                      (wages_fe[2,1]+wages_fe[2,2])*xp,
    high_grade == 11 ~ wages_fe[1,1] + wages_fe[1,2] + 
                      wages_fe[7,1] + wages_fe[7,2] + 
                      (wages_fe[2,1]+wages_fe[2,2])*xp,
    high_grade == 12 ~ wages_fe[1,1] + wages_fe[1,2] + 
                      wages_fe[8,1] + wages_fe[8,2] + 
                      (wages_fe[2,1]+wages_fe[2,2])*xp)
  ) 

ggplot() + 
  geom_ribbon(data=wages_fe_d, 
            aes(x=xp, 
                ymin=ln_wages_l,
                ymax=ln_wages_u,
                fill=high_grade), colour=NA, alpha=0.1) +
  geom_line(data=wages_fe_d, 
            aes(x=xp, 
                y=ln_wages, 
                colour=high_grade, 
                group=high_grade)) +
  scale_fill_discrete_divergingx(palette = "Zissou 1") +
  scale_colour_discrete_divergingx(palette = "Zissou 1") +
  labs(x="Experience (years)", y="Wages (ln)", colour="Grade", fill="Grade") 

```

:::

:::
::::

## individual fits

:::: {.columns}
::: {.column width=40%}

Examine individual fits. Too many to show all - sample multiple times to get through them all. 

:::

::: {.column }

::: {style="font-size: 70%;"}

```{r}
#| label: indiv-fits
#| fig-width: 10
#| fig-height: 7
#| out-width: 100%
wages_full <- wages_fct |>
  add_predictions(wages_fit, 
                  var = "pred") |>
  add_residuals(wages_fit, 
                var = "res")
set.seed(1222)
wages_full |> add_n_obs() |> filter(n_obs > 4) |>
  sample_n_keys(size = 12) |>
  ggplot() + 
  geom_line(aes(x = xp, y = pred, group = id, 
             colour = factor(id))) + 
  geom_point(aes(x = xp, y = ln_wages, 
                 colour = factor(id))) + 
  facet_wrap(~id, ncol=4)  +
  xlab("Experience (years)") + ylab("Wages (ln)") +
  theme(aspect.ratio = 0.6, legend.position = "none")
```
:::

:::
::::


## which is honest?

Note that, this particular model fit makes the assumption that wages increase linearly with years of experience. 

- Plotting the model alone suggests higher education increases wages (by XXX), particularly if the student has 12 years (full high school).
- Adding the individual level observations shows the large individual-to-individual variability, which swamps the education differences. It also suggests the individual observations might not have linear increase.
- Adding representation of the standard error shows the "overlap" between education levels, that the estimate for wage increase with 12 years of education is not substantially better than 10 years, but it is better than 6 years. 


:::



## Perception and uncertainty

:::: {.columns}
::: {.column width=70%}

- There can be multiple measures of uncertainty
    - Example had two measurement levels - fixed effect/demographic strata, random effects/individuals - but multiple ways to represent these.
    - A classical example is: in a simple regression we have confidence intervals for the model estimates, and also predictive intervals for predicting new observations.
- Uncertainty is not just another variable. It might be encoded in the data as an extra column. 

:::
::: {.column width=30%}

<br><br><br><br><br><br><br><br>

::: {.fragment}

::: {.callout-note appearance="simple"}

::: {style="font-size: 150%;"}

Multiple pieces of information on a plot tends to interfere with the perception of either one.

:::
:::

:::

:::
::::

## Perceptual principles

```{r}
#| echo: false
V1 = tibble(x = 1:7, 
            native = factor(c("quoll", "emu", "roo", 
            "bilby", "quokka", "dingo", "numbat")))
c1 <- ggplot(V1, aes(x=x, y=1, fill=native)) +
  geom_tile() +
  geom_text(aes(x=x, y=1, label=native)) +
  ggtitle("qualitative") + 
  theme_minimal() +
  theme(legend.position = "none", 
        panel.background =
                    element_rect(fill = 'transparent', colour = NA),
        axis.text = element_blank(),
        axis.title = element_blank(),
        axis.ticks = element_blank(),
        #axis.line = element_line(colour = "white"),
        panel.grid.major = element_line(colour = "white"),
        panel.grid.minor = element_line(colour = "white"))
V2 = tibble(x = 1:7, 
            fill = 1:7)
c2 <- ggplot(V2, aes(x=x, y=1, fill=fill)) +
  geom_tile() +
  geom_text(aes(x=x, y=1, label=fill)) +
  ggtitle("sequential: emphasise high") + 
  scale_fill_continuous_sequential(palette = "PinkYl") +
  theme_minimal() +
  theme(legend.position = "none", 
        panel.background =
                    element_rect(fill = 'transparent', colour = NA),
        axis.text = element_blank(),
        axis.title = element_blank(),
        axis.ticks = element_blank(),
        #axis.line = element_line(colour = "white"),
        panel.grid.major = element_line(colour = "white"),
        panel.grid.minor = element_line(colour = "white"))

V3 = tibble(x = 1:7, 
            fill = -3:3)
c3 <- ggplot(V3, aes(x=x, y=1, fill=fill)) +
  geom_tile() +
  geom_text(aes(x=x, y=1, label=fill)) +
  ggtitle("diverging: emphasise high and low") + 
  scale_fill_continuous_divergingx(palette = "ArmyRose") +
  theme_minimal() +
  theme(legend.position = "none", 
        panel.background =
                    element_rect(fill = 'transparent', colour = NA),
        axis.text = element_blank(),
        axis.title = element_blank(),
        axis.ticks = element_blank(),
        #axis.line = element_line(colour = "white"),
        panel.grid.major = element_line(colour = "white"),
        panel.grid.minor = element_line(colour = "white"))
```

:::: {.columns}
::: {.column width=70%}

- **Hierarchy** of mappings: 
    1. *Position - common scale* (BEST): scatterplot, barchart
    2. *Position - nonaligned scale*: side-by-side boxplot, stacked barchart
    3. *Length, direction, angle*: piechart, rose plot, gauge plot, donut, wind direction map, starplot
    4. *Area*: treemap, bubble chart, mosaicplot
    5. *Volume*, curvature: chernoff face
    6. *Shading, color* (WORST): choropleth map
- **Pre-attentive**: noticed before you even realise it.
- **Color palettes**: qualitative, sequential, diverging.
- **Proximity**: Place elements for primary comparison close together. 
- **Change blindness**: When focus is interrupted differences may not be noticed.

:::
::: {.column width=30%}

<br><br><br><br><br><br><br><br><br>

```{r}
#| echo: false
#| fig-width: 6
#| fig-height: 2
#| out-width: 100%
c1 + c2 + c3 + plot_layout(ncol=1)
```
:::
::::

## Applying these to making plots

- Map primary information to pre-attentive elements like colour
- Place items to compare first near each other
- When using colour to map a two-ended continuous variable use a diverging palette, and conversely, for low-high continuous variable usa a sequential palette
- Axes and labels should be faint in the background, to be examined only when needing to interpret or quantify patterns
- Order items, categories by a numerical rank
- For separate plots, common axes to make comparison easier

## Application to uncertainty visualisation

:::: {.columns}
::: {.column width=70%}

1. Make the main thing pre-attentive. It will draw attention to it first. 
2. Map the uncertainty to a lower level of attentiveness.
3. Uncertainty needs to be placed with the main thing in order to make comparison

:::
::: {.column width=30%}

::: {style="font-size: 120%;"}

::: {.fragment}
<br><br><br><br><br><br>

*At the core of statistical reasoning is asking* **compared to what**.
:::

:::

:::
::::

## Example

:::: {.columns}
::: {.column}

What principle(s) is this using?

```{r}
#| label: SE
#| fig-width: 6
#| fig-height: 4
#| out-width: 100%
#| echo: false
```
:::

::: {.column}

::: {.fragment}
What principle(s) is this using?

```{r}
#| label: indiv-fits
#| fig-width: 10
#| fig-height: 7
#| out-width: 100%
#| echo: false
```
:::
:::
::::

## Exercise 2

:::: {.columns}
::: {.column}

Take a look at the plots made in Exercise 1. Ask yourself whether the main thing is pre-attentive, and the uncertainty representation is sitting a little into the background?

Tinker with the design of one plot to make it better fit this principle.
:::
::: {.column}
Add solutions here

:::
::::


```{r}
#| echo: false
countdown::countdown(10, left="25%", bottom="40%",
  color_background="#027EB6",
  color_text="white",
  color_running_background="#027EB6",
  color_running_text="white",
  color_finished_background="#D93F00")
```


<!-- *notes taken from useR talk slides*-->

<!-- Why can't we just treat uncertainty as another variable?
* Uncertainty is not just another variable‚Ä¶
    * It presents an interesting perceptual problem
    * Two sides of the same coin
* Usually do not want variables to interfere with each other
    * In uncertainty visualisation, the opposite is true
    * This is the core of the signal suppression approach we implement-->

<!-- Need to have a gene expression example with rationale here 
and to emphasize "compared to what" -->

# Uncertainty representation in different types of problems {.transition-slide}

##

*from the ggdibbler notes the conditional line plot. All the examples are from time series packages, because I spent a bit of time looking for the one that returned a distributional forecast so I could use it in an example*

Common ways we express uncertainty in R and when you would see them out in the wild?
- Distributional (vectorised distributions that are wrappers on the d, p, q, r functions) 
    - e.g. when you get it as output - fable, some Bayes stuff (e.g. posterior)
- Base R (d, p, q, r functions)
- Confidence intervals
    - hi low variables in the forecast packages
- Bootstrapping (?)


# Deciding which is the best design {.transition-slide}

##

<!-- *notes taken from useR talk slides* -->

Evaluation criteria - Uncertainty visualisation should:

1. Reinforce justified signals
2. Hide signals that are just noise
Similar logic to a hypothesis test (but not as binary, and without set thing you are checking for)

<!-- *notes taken from useR talk slides*-->

Accessibility considerations

- Colour
    - 2D palette is harder to read as colour is not a simple 3D space. Mapping a variable to saturation hurts accessibility.
(Maybe specifically mention this in section 2?. I am not sure of other accessibility issues other than colour issues (and maybe size?).

## Miscellaneous

- bag plot
- model only (regression, wages example) vs adding data
- ggdist
- tidyindex
- animation over space

## Where to learn more

- Spiegelhalter, D. (2017), [Risk and uncertainty communication](https://www.annualreviews.org/docserver/fulltext/statistics/4/1/annurev-statistics-010814-020148.pdf)

## End of session 1 {.center}

<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.

